Exercise 4 Written Answer

We have created a class UDPClient and class UDPServer
that tries to reliably transmit a string of length less than 255 characters.  

The UDPClient class has been modified to make it possible to handle corrupted, duplicated and missing packets:

Firstly, we generate a hash code for each message String and send it together in the packet with the message
to make it possible to check for corrupted messages. The idea is to match the message String's hashcode
and the hash code send along with it in the UDPServer to see if the message has been corrupted during the transmission.
We are aware that a possibility exists for the hash code itself to be corrupted during the transmission, but after 
discussing the issue with our TA, we came to the conclusion that it was sufficiently small for the needs of our program.
Also, we concatenate the hash code and the message and isolate the hash code using $ on both sides of it.
This is used to make a split operation in the UDPServer and separate the message and hash code for comparison.
We know that this is not an optimal solution since it means that our message transmission will go wrong if the user
tries to send a message containing a $.
A better solution would have been to add the message data and hash code to a byte array
and then extract the data directly from the byte array using ByteBuffer.

Secondly, we always wait for the UDPServer to respond by using a timeout in the UDPClient while awaiting a response. 
If a packet has not been received, no respond will come from the UDPServer which will result in the UDPClient resending the packet (this is done up to 3 times). The logic behind resending 3 times
was the fact that something had to be wrong with the connection if the packet had not yet been received at this point of time. Thus,
we want to stop the attempt of resending the packet instead of keeping the program running.
 
Thirdly, to avoid duplicates we use a HashMap<InetAddress, Integer> to map the IPaddress of a user to the hash code
of the latest DatagramPacket received from this user.
When a packet is received we can do the duplicate check in expected constant time by extracting the IPAddress from the received packet and check if its hash code is equal to the value 
of the previous packet which is saved in the HashMap.
The downside of this method is memory usage for storing this information is linear in the number of IPAddresses.

Another way to avoid duplicates one could instead have used a ticket system, which could be done in the following way:
    1. The client sends a request to the UDPServer to get promission to send a message.
    2. If the server accepts the request it sends back a ticket for the client and registers the ticket number
       and client IPAddress.
    3. The client now holds the ticket information which it sends together with the message.
    4. When the server receives the packet it can then check the ticket information and IPAddress
       to see if the packet should be accepted.

This way the memory usage is only linear in the number of tickets which would presumably be a lot less than the number of users if the system were to support a larger user base.

A problem with this is that the system could, in fact, end up holding unused tickets 
e.g. if a client receives a ticket but crashes before sending its message or if a message gets lost for a year
before arriving at the server. 
A way to solve this problem could be to have different types of tickets with different expiration dates
depending on the importance of the message. The client could then know the importance of the message 
and request a certain kind of ticket from the server. 
E.g. a normal chat message could expire after say a week while a pentagon clearance level 6 message might first
expire after 10 years or more.